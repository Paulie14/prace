% \begin{abstract}
% The XFEM and Mortar methods can be used in combination with non-matching or non-conforming grids 
% to deal with problems on complex geometries. However, the information about the mesh intersection must be provided.
% We present algorithms for intersections between 1d and 2d unstructured multi component simplicial meshes 
% and their intersections with a~background unstructured 3d mesh. A~common algorithm 
% based on the advancing front technique is used for the efficient selection of candidate pairs among 
% simplicial elements. Bounding interval hierarchy (BIH) of axes aligned bounding boxes (AABB) of elements
% is used to initialize the front tracking algorithm. The family of element intersection algorithms
% is built upon a~line-triangle intersection algorithm based on the \plucker
% coordinates. These algorithms combined with the advancing front technique can reuse the results of calculations 
% performed on the neighbouring elements and reduce the number of arithmetic operations. Barycentric coordinates
% on each of the intersecting elements are provided for every intersection point. Benchmarks 
% of the element intersection algorithms are presented and three variants of the global intersection 
% algorithm are compared on the meshes raising from hydrogeological applications.
% \end{abstract}


In the previous chapter we studied the application of XFEM in a~model where the reduced dimension concept
and incompatible meshes are used. So far, we have not mentioned how the intersections of the meshed domains of different dimensions
are computed. In our case these are the intersections of non-planar 1d-2d meshes and 1d-3d meshes. 
Even though we consider only straight 1d domains in our well-aquifer models, where the computation of the intersections is not overly demanding,
we look at this topic from a~more general perspective and dive deeper into intersection algorithms.

The motivation to solve the intersections of meshes more generally originates from our needs and future vision.
The concept of the compatible meshes provides a~great tool up some geometry complexity,
however the compatible meshing becomes painful or even impossible as the number of separate domains (fractures and wells) increases.
There are approaches available for computations on incompatible meshes, especially of codimension 1, including XFEM of course.
The Chimera method \cite{brezzi_analysis_2001}, also called overset grid, and similarly Nitche method \cite{massing_efficient_2013}
allow solution of the problems with a~changing geometry, e.g. in fluid-structure problems. 
The Mortar method \cite{belgacem_mortar_1999, pichot_generalized_2012} allows domain decomposition, independent meshing of domains,
and supports sliding boundaries.
A~Mortar like method~\cite{brezina_2012} is also experimentally implemented in Flow123d.

Recently, the Multilevel Monte Carlo (MLMC)~\cite{giles_mlmc_2015} has been developed extensively and it has become attractive also
in underground processes simulations, where it is used in uncertainty quantification analysis in DFN~\cite{berrone_uncertainty_2015, berrone_uncertainty_2018}.
One of the principles in DFN with MLMC is a~generation of the fractures randomly and there the construction of 
incompatible meshes is indisputably more convenient.
Similarly in problems with time evolving fracture network, e.g. in modeling of hydraulic fracking,
a~fast and robust mesh construction is required, which is not generally satisfied in case of compatible meshes.

The prerequisite for any of these applications is a~fast and robust algorithm for calculating intersections of the individual meshes.
The content of this chapter includes the results published in our article~\cite{brezina_2017}.



\section{Introduction}
% The grid intersection algorithms are crucial for several techniques that try to overcome some limitations of the classical finite element method.
% The Chimera method \cite{brezzi_analysis_2001}, also called overset grid, and similar Nitche method \cite{massing_efficient_2013}
% allow solution of the problems with changing geometry as in the fluid-structure problems. 
% The Mortar method \cite{belgacem_mortar_1999} allows domain decomposition, independent meshing of domains, and supports sliding boundaries.
% However, our primal motivation is usage of XFEM methods \cite{fries_xfem_overview_2010} and non-matching meshes of mixed dimension in groundwater models.

% The realistic models of groundwater processes including the transport processes and geomechanics have to deal with 
% a~complex nature of geological formations containing various small scale features as fractures (or fractured zones) and wells. 
% Although of small scale, these features may have significant impact 
% on the global behavior of the system and their representation in the numerical model is imperative. For example the fractures may form preferential 
% paths which allow much faster transport that cannot be fully captured by equivalent continuum.
% One possible approach is to model fractures and wells as lower dimensional objects and introduce their coupling with the surrounding continuum. 
% The discretization then leads to the meshes of mixed dimensions, i.e. composed of elements of different dimension. This approach 
% called mixed-dimensional analysis in the mechanics \cite{bournival_mesh-geometry_2008} is also studied in the groundwater context, see e.g. 
% \cite{martin_modeling_2005}, \cite{fumagalli_numerical_2011}, \cite{brezina_analysis_2015} and 
% already adopted by some groundwater simulation software, e.g FeFlow \cite{trefry_feflow_2007} and Flow123d \cite{flow123d}.
% Nevertheless as the complexity of the geometry increases (e.g. when lots of fractures are randomly generated) the compatible meshing becomes painful or even 
% impossible. In order to avoid these difficulties we may discretize the continuum and every fracture and well independently, getting a~non-matching 
% (or incompatible) mesh of mixed dimensions and then apply XFEM to represent jumps of the solution on the fractures or singularities 
% at the wells.
% The prerequisite for such approach is a~fast and robust algorithm for calculating intersections of individual meshes.
% Although it is (currently) out of our interest, the non-matching mesh approach allows a~time evolving network of fractures necessary e.g. in 
% modeling of hydraulic fracking.

We consider a~composed mesh $\mathcal T$ consisting of simplicial meshes $\mathcal T_d$, $d\in \{1,2,3\}$ in the 3d ambient space.
For the purpose of this chapter, we further denote a~submesh $\mathcal T^i \subset \mathcal T$, $i=1\ldots N_\mathcal{T}$,
a~connected set of elements of the same dimension with no self intersection. We assume only a~single 3d mesh $\mathcal T^1=\mathcal T_3$.
The mesh intersection problem is to find all pairs of elements $L\in \mathcal{T}_i$, $K\in \mathcal{T}_j$, $i\ne j$ that have a~non-empty intersection 
and to compute that intersection.
The solution of the mesh intersection problem consists of two major steps: first, generating a~set of candidate pairs $(K, L)$;
second, computing the intersection of each pair.

% We consider a~composed mesh $\mathcal T$ consisting of simplicial meshes $\mathcal T_i$ of dimensions $d_i \in \{1,2,3\}$, $i=1,\dots,N_\mathcal{T}$
% in the 3d ambient space. We assume that every mesh $\mathcal T_i$ is a~connected set with no self intersection.
% Further we assume only single 3d mesh $\mathcal{T}_1$.
% The mesh intersection problem is to find all pairs of elements $L\in \mathcal{T}_i$, $K\in \mathcal{T}_j$, $i\ne j$ that have non-empty intersection 
% and to compute that intersection. The mesh intersection problem consists of the two parts: the first, generating a~set of candidate pairs $(K, L)$;
% the second, computing the intersection of a~particular pair.

According to our knowledge, there are lots of works using incompatible meshes, yet only a~few of them discuss algorithms how to compute their intersections. 
Gander and Japhet \cite{gander_algorithm_2013} present the PANG algorithm for 2d-2d and 3d-3d intersections that can be used e.g. for mesh overlapping methods.
They use the advancing front technique to get candidate pairs in a~linear time. The algorithm is a~part of the library DUNE \cite{bastian_towards_2005}.
Massing, Larson, and Logg \cite{massing_efficient_2013} present an algorithm for 2d-3d intersections included in their implementation of the Nitche method 
which is a~part of the project Dolfin \cite{dolphin_2012}. They use the axes aligned bounding boxes of elements (AABB) and bounding interval hierarchy (BIH) 
to get intersection candidate pairs of elements, while the GTS library \cite{gtslib} is used for 2d-3d intersections. 
Finally, there is the work of Elsheikh and Elsheikh \cite{elsheikh_reliable_2012} presenting an algorithm for 2d-2d mesh union operation which includes 
calculation and imprinting of the intersection curves. They exploit the binary space partitioning for searching of the initial intersection and 
the advancing front method for the intersection curve tracking. 

Our approach to the mesh intersection problem is based on the \plucker coordinates,
further developing the algorithm of Platis and Theoharis \cite{platis_fast_2003} for ray-tetrahedron intersections. 
The \plucker coordinates play important role in the algorithms for intersection of simplicial elements.
These algorithms are combined with the advancing front method which allows us to reuse \plucker coordinates and their products among neighboring
elements and to reduce the number of arithmetic operations. 

%TODO: 2d-2d
At first, the algorithms for 1d-2d, 1d-3d, 2d-3d and 2d-2d intersections of simplices are described.
Then we discuss our implementation of the advancing front technique and the usage of AABB and BIH for its initiation.
Finally, several benchmarks are presented and the individual algorithms are compared.


\section{Element Intersections}
\label{sec:element intersecitons}
In this section, we present algorithms for computing the intersection of a~pair of simplicial elements of a~different dimension in a~3d ambient space. 
% In particular we address intersection algorithms for 1d-2d, 1d-3d, 2d-3d pairs of elements. 
The fundamental idea is to compute intersection of 1d-2d 
simplices using the \plucker coordinates and to reduce all the other cases to this one. 
%TODO: 2d-2d
% We have implemented the case 2d-2d as well, however the treatment 
% of all special cases is quite technical and not fully tested yet.

We denote $S_i$ a~simplicial element with $i+1$ vertices (of dimension $i$). We call vertices, edges, faces and simplices themselves the \nfaces and we denote
$M_i$ the set of all \nfaces of the simplex $S_i$.
In general, an intersection can be a~point, a~line segment or a~polygon called \emph{intersection polygon} (IP) in common.
The intersection polygon is represented as a~list of its corners called \emph{intersection corners} (IC). The IP data structure keeps also 
a~reference to the intersecting simplices. A~data structure of a~single IC consists of:
\begin{itemize}
 \item the barycentric coordinate $\vc w_K$ of IC on the element $K$,
 \item the dimension $d_K$ of the lowest dimensional \nface the IC is lying on,\\
    e.g. an IC on an edge have $d_K=1$ although it also lies on the connected faces,
 \item the local index $i_K$ of that \nface on $K$,
\end{itemize}
for each intersecting element $K$ of the pair. The pair $\tau_K = (d_K, i_K)$
is called the \emph{topological position} of the IC on  $K$. Moreover, since every IC is a~result of a~permuted
inner product of some \plucker coordinates (defined below in Section \ref{sec:1d-2d}), we store the sign of the product as well.


\subsection{\plucker Coordinates}
\plucker coordinates represent a~line in a~3d space. The definition, properties and the~more general context from computational 
geometry can be found e.g. in \cite{dorst_geometric_2007} or \cite{joswig_plucker_2013}.
Considering a~line $p$, given by a~point $\vc A_p$ and its directional vector $\vc{u}_p$, 
the \plucker coordinates of $p$ are defined as
\begin{equation} \label{eqn:plucker_coordinates}
    \pi_p = (\vc{u}_p, \vc{v}_p), \quad \vc{v}_p = \vc{u}_p\times \vc A_p.
\end{equation}
This representation is independent of the choice of $\vc A_p$ since $\vc{u}_p\times (\vc A_p + t \vc u_p) = \vc{u}_p\times \vc A_p$,
$t\in\Real$. Further, having two lines $p$ and $q$ with \plucker coordinates $\pi_p$ and $\pi_q$, we denote a~permuted inner product
\begin{equation} \label{eqn:plucker_product}
    \pi_p \odot \pi_q = \vc{u}_p\cdot \vc{v}_q + \vc{u}_q \cdot \vc{v}_p.
\end{equation}    

\begin{figure}[!htb]
    \centering
    \subfloat[$\pi_p\odot \pi_{s_i} < 0 \;\forall i$]{
        \includegraphics[width=0.25\textwidth]{\figpathins plucker_product_a.pdf}
    }
    \hspace{2ex}
    \subfloat[$\pi_p\odot \pi_{s_i} = 0 \, \exists i$, \newline special case]{
        \includegraphics[width=0.25\textwidth]{\figpathins plucker_product_b.pdf}
    }
    \hspace{2ex}
    \subfloat[$\pi_p\odot \pi_{s_i} > 0 \;\forall i$]{
        \includegraphics[width=0.25\textwidth]{\figpathins plucker_product_c.pdf}
    }
    \caption[Geometric illustration of \plucker products.]
    {Different relative positions of a~line $p$ and a~triangle with sides $s_i$, $i=0,1,2$. 
        The dashed parts of $p$ are hidden behind the triangle. The signs of the permuted inner products depend on the orientation of lines,
        the line $p$ is coplanar with the~side in case (b).}
    \label{fig:plucker_products}
\end{figure}
%
The sign of the permuted inner product is non-zero if $p$ and $q$ are skew lines and is positive if $q$ is oriented counterclockwise and 
negative if $q$ is oriented clockwise looking in the $p$ direction. This can be used to determine the relative position 
of the line $p$ and the triangle. This is demonstrated in \fig{fig:plucker_products}.
The permuted inner products of the triangle sides with the line $p$ have a~common sign, cases (a) and (c), if and only if the 
line intersects the triangle inside. If any $\pi_p\odot \pi_{s_i}$ is zero, as in the case (b), 
it means that the lines $p$ and $s_i$ are coplanar.



% \begin{figure}[!htb]
%   \begin{center}        
%     \includegraphics[width=0.7\textwidth]{\figpathins plucker_product.pdf}
% %    \includegraphics{\figpathins plucker_products.pdf}
%   \end{center}
%   \caption{Sign of the permuted inner product is related to the relative position of the two oriented lines.
%            Dashed line symbolizes that the line is in the back, the lines intersect in the middle case.
%            \notePE{circle dot permuted inner product}}
%   \label{fig:plucker_products}
% \end{figure}


%Notice the condition on the orientation of the triangle sides. To always satisfy it, we use a
%reference simplex, in which the numbering of nodes and sides and also the orientation is fixed.
%The barycentric coordinates of the intersection corner can be computed directly from the \plucker products
%and then we can easily obtain its real coordinates (see \cite{fris_dp_2015} for derivations and details).

\subsection{Intersection Line-Triangle (1d-2d)}
\label{sec:1d-2d}
Let us consider a~line $p$ with parametric equation 
\begin{equation}
    \label{eq:line_parametric}
    \vc X = \vc A + t\vc u,
\end{equation}
on which a~line segment $S_1$ is defined by $t\in [0,1]$ and a~triangle $S_2$ given by vertices $(\vc V_0, \vc V_1, \vc V_2)$ 
with oriented sides $s_i=(\vc V_j, \vc V_k)$, $j=(i+1)\text{ mod }3$, $k=(i+2)\text{ mod }3$, see \fig{fig:triangle_notation}.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.5\textwidth]{\figpathins triangle_notation.pdf}
    \caption{Notation for Lemma \ref{lemma_barycentric}.}
    \label{fig:triangle_notation}
\end{figure}

\begin{lemma}
\label{lemma_barycentric}
The permuted inner products $\pi_p \odot \pi_{s_i},\, i=0,1,2$ have the same non-zero sign if and only if there
is an intersection point $\vc X$ on $p$ and inside the triangle $S_2$. 
The barycentric coordinates of $\vc X$ on $S_2$ are
\begin{equation}
  \label{eq:bary_centric}
   w_i = \frac{\pi_p \odot \pi_{s_i}}{w},\quad w=\sum_{i=0}^{2} \pi_p \odot \pi_{s_i}.
\end{equation}
\end{lemma}
\begin{proof}
Using the barycentric coordinates, the intersection point can be expressed as $\vc X = \vc V_0 + w_1 \vc s_2 - w_2 \vc s_1$.
The line $p$ has \plucker coordinates $(\vc u, \vc u \times \vc X)$ since these are invariant to a~change of the initial point. 
Combining these two expressions and substituting for $\vc V_0-\vc V_2=\vc s_1$, we get for the side $\vc s_1$
\[
   \pi_p \odot \pi_{s_1} = \vc u \cdot (\vc s_1 \times \vc V_2) + \vc s_1 \cdot ( \vc u \times [\vc V_0 + w_1\vc s_2 - w_2 \vc s_1])
   =-w_1 \vc u \cdot (\vc s_1 \times \vc s_2).
\]
Since $\vc s_0 + \vc s_1 + \vc s_2=0$, we have $ \vc s_1 \times \vc s_2 = \vc s_2 \times \vc s_0 = \vc s_0 \times \vc s_1$, and thus
\begin{eqnarray}
   \pi_p \odot \pi_{s_i} &=& -w_i \vc u \cdot (\vc s_1 \times \vc s_2), \label{eq:bary_centric_part1}\\
   \sum_{i=0}^{2} \pi_p \odot \pi_{s_i} &=& - \vc u \cdot (\vc s_1 \times \vc s_2). \label{eq:bary_centric_part2}
\end{eqnarray}
The result \eqref{eq:bary_centric} then follows directly from the combination of \eqref{eq:bary_centric_part1} and \eqref{eq:bary_centric_part2}.
The point $\vc X$ is inside $S_2$ if and only if $w_i>0$ for all $i=0,1,2$.
\end{proof}
Having the barycentric coordinates of $\vc X$ on $S_2$, we can compute also its local coordinate on $p$ from its parametric form:
\begin{equation}
   \label{eq:line}
   X_i  = A_i + t u_i, \text{ for } i=1,2,3
\end{equation}
We use $i$ with maximal $|u_i|$ for practical computation. 

\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.9\textwidth]{\figpathins 1d-2d_cases.pdf}
    \caption{Some possible cases of the 1d-2d algorithm.}
    \label{fig:1d2d_cases}
\end{figure}

All the possible intersections of $p$ and $S_2$ are displayed in \fig{fig:1d2d_cases}.
Considering a~given geometric tolerance $\epsilon$,  the calculation of the intersection proceeds as follows:
\begin{enumerate}
    \item Compute or reuse the \plucker coordinates and the permuted inner products: $\pi_p$, $\pi_{s_i}$, $\pi_p \odot \pi_{s_i}$, for $i=1,2,3$.
    \item \label{item:zero_total} If the total $w$ of the products is less then $\epsilon L_1 L_2^2$, jump to the coplanar case in the step \ref{item:coplanar}.
          $L_1$ and $L_2$ are defined bellow.
    \item Compute the barycentric coordinates $w_i,\ i=1,2,3$ using \eqref{eq:bary_centric}.
    \item If any $w_i$ is less than $-\epsilon$, there is no intersection. Then an empty IP is returned. See the case (a) in \fig{fig:1d2d_cases}.          
    \item If all $w_i$ are greater than $\epsilon$, we set $\tau_{S_2} = (2, 0)$ for the IC. \\
        \fig{fig:1d2d_cases}, (b).
    \item If one $w_i$ is less than $\epsilon$, the intersection lies on the edge $s_i$ and we set $\tau_{S_2} =(1,i)$. \\
        \fig{fig:1d2d_cases}, (c).
    \item If two $w_i$ are less than $\epsilon$, the intersection is at the vertex $\vc V_i$, we set $\tau_{S_2}=(0,i)$. \\
        \fig{fig:1d2d_cases}, (d).
    \item \label{item:coplanar} If all $w_i$ are less than $\epsilon$, then the line is coplanar with the triangle. Both objects are 
        projected to the plane $x_i=0$ where $i$ is the index of the maximal component of the triangle's normal vector.
        Every pair $(p$, $s_i)$ is checked for an intersection on $S_2$ boundary, either inside $s_i$ or at a~vertex $\vc V_i$, 
        setting the topological position $\tau_{S_2}$ to 
        $(1, i)$ or $(0, i)$, respectively. The ICs (at most two) obtained in this coplanar case will be called 
        \emph{degenerate} and will later need a~special treatment.
    \item For each IC the barycentric coordinates $(1-t, t)$ on the line $p$ are computed according to \eqref{eq:line}. 
    \item \label{item:ic_snap} If $t\in (-\epsilon, \epsilon)$ or $t\in (1-\epsilon, 1+\epsilon)$,
        we set the end point of $S_1$: $\tau_{S_1} = (0,0)$ or $\tau_{S_1} = (0,1)$, respectively.
    \item \label{item:ic_elimination} If $t\notin (-\epsilon, 1+\epsilon)$, the IC is eliminated.
\end{enumerate}

In order to make the test in the step \ref{item:zero_total} independent of the  scale of the elements,
we use the characteristic lengths $L_1$ and $L_2$ of $S_1$ and $S_2$ respectively.
Further, the algorithm depends on the parameter $\epsilon$ which is used as a~common tolerance parameter for detection of ICs with special positions. First, it is used in the sign check for the permuted inner products, second, it is used for the topological check on the line.
Only these two kinds of geometric predicates are used through all the intersection algorithms. Currently, we use a~fixed value $\epsilon=10^{-9}$.
This value is close to the machine epsilon ($10^{-16}$ of the double precision 
arithmetic), while far enough to keep precision of the further calculations. Let us note that the algorithm is susceptible to the loss of significance 
due to cancellation during the evaluation of the products. Nevertheless, the algorithm works on all realistic meshes we deal with.

Other problem that would deserve further investigation is possible inconsistent result of two different, but logically related predicates. 
Adaptive-precision evaluation of the geometric predicates was designed by Schewchuk \cite{shewchuk_adaptive_1997} and used for 2d-2d mesh
intersections in \cite{elsheikh_reliable_2012} in order to deal with these inconsistencies. It is a~topic for future work to understand
the dependency between our geometric predicates and to decide if the adaptive-precision is the only way to guarantee the correctness
of the algorithm even for various corner cases.

%\noteJB{Can we make the algorithm 
%\emph{parsimonious} in the spirit of the Fortune \cite{fortune_stable_1989} quoted by Schewchuk? 
%Seems that our problem is more local than the line example that was proven to be NP-hard.}

The algorithms for 1d-3d and 2d-3d intersections use simpler version of the 1d-2d intersection algorithm,
in particular the search for ICs in the coplanar case 
(step \ref{item:coplanar}) is not necessary, and the tests in the last two steps \ref{item:ic_snap}-\ref{item:ic_elimination} are not performed.


\subsection{Intersection Line-Tetrahedron (1d-3d)}
Let us now consider an intersection of a~line segment $S_1$, defined by a~parameter $t\in [0,1]$ of the line $p$ defined in \eqref{eq:line_parametric}, with a~tetrahedron $S_3$. The algorithm is based on the 1d-2d algorithm and closely follows \cite{platis_fast_2003}. Our modification takes into account
the intersection with the line segment and consistently propagates topological positions of ICs.

\begin{algorithm}
  \caption{1d-3d intersection}
  \label{algo:13d}

  \DontPrintSemicolon
  \KwIn{Line segment $S_1$ of line $p$, Tetrahedron $S_3$.}
  \KwOut{List $I$ of ICs sorted along $p$.}  
  $I=\{\}$\; 
  \For{unmarked face $f$ of $S_3$}{
    $L$ = \intersectionA{$p,f$}\; \label{line:13-intersection}
    \lIf{ $L$ is none or degenerate}{\kwcontinue} \label{line:13-noIC}
    \If{ $L$ is inside the edge $e$}{ \label{line:13-edgeIC}
        set $\tau_{S_3} = (1,e)$\;
        mark faces incident to $e$
    }
    \ElseIf{ $L$ is at the vertex $v$}{ \label{line:13-vertexIC}
        set $\tau_{S_3} = (0,v)$\;
        mark faces incident with $v$
    }
    append $L$ to $I$\; \label{line:13-append}
    \lIf{$\abs{I}=2$}{\kwbreak}
  }
  \lIf{$\abs{I}=1$ \kwand   $I$ is outside of $S_1$}{ erase $I$} \label{line:trimming}
  \ElseIf{$\abs{I}=2$}{    
    trim intersection with respect to the line segment $S_1$
  }
\end{algorithm}
\algo{algo:13d} first computes line-face intersections for every face of $S_3$.
A~tetrahedron has six edges, so 7 \plucker coordinates and 6 permuted inner products are computed at most. 
The precomputed coordinates and products are passed into the 1d-2d algorithm which is performed for the infinite 
line $p$ (line \ref{line:13-intersection}), i.e. steps \ref{item:coplanar}, \ref{item:ic_snap}, \ref{item:ic_elimination} in Section~\ref{sec:1d-2d} are not performed.
If no IC is found or a~coplanar case occurs in the line-face computation (line \ref{line:13-noIC}), we continue to the next face. Note, ICs that would 
be created in coplanar case are to be found as ICs with the other faces since they lie on edges.

Next, an IC can be on an edge (line \ref{line:13-edgeIC}) or at a~vertex (line \ref{line:13-vertexIC}); then we set the correct topological position and mark the adjacent faces
to be skipped, since there cannot be another IC (and coplanar case has been checked already).
Finally at the line \ref{line:13-append}, we append the IC to the result and check whether the maximal amount of 
ICs has been reached.

After collecting line-tetrahedron ICs,
we do the line segment trimming from the line \ref{line:trimming} further. 
If we have only one IC, we check that it actually lies inside $S_1$, otherwise we throw it away.
If we have two ICs, and if both lie outside $S_1$, we eliminate both of them. 
If one of the ICs lies out of $S_1$,
we use the closest end point of the line segment instead and interpolate its barycentric coordinates on $S_3$.
The topological positions $\tau_{S_1}$ and $\tau_{S_3}$ are updated as well.
The result of \algo{algo:13d} is 0, 1, or 2 ICs, sorted by the parameter $t$ in the direction of the line $p$.



\subsection{Intersection Triangle-Tetrahedron (2d-3d)}
The intersection of a~triangle $S_2$ and a~tetrahedron $S_3$ is an $n$-side intersection polygon (IP), $n\le 7$. The sides of the polygon
lie either on the sides of $S_2$ or on the faces of $S_3$. Thus each vertex (IC) of the polygon
can arise either from a~side-face intersection, or from an edge-triangle intersection, or be a~vertex of $S_2$.
To get all ICs, we have to compute at most 12 side-face intersections and at most 6 edge-triangle intersections. However,
to this end we only need to compute 9 \plucker coordinates (3 sides, 6 edges) and 18 permuted inner products, one for every side-edge pair.
The computation of IP consists of three stages: a~calculation of side-tetrahedron ICs, 
a~calculation of edge-triangle ICs, an ordering of ICs.


% \subsubsection{Successor tables}
The intersection corners are appended to the list $I$ as they are computed, however their final order in IP is 
given indirectly by the \emph{successor tables} $F_c[:]$ and $F_f[:]$. Every side of IP that lies on an \nface $x\in M_2\cup M_3$ is followed by an 
IC given by $F_c[x]$. Every IC $p$ is followed by the side of IP that lies on the \nface $y=F_f[p]\in M_2\cup M_3$ (see an example in \fig{fig:tracing}).
After an IC $p$ is computed, we also obtain two $n$-faces $x$, $y$ incident with the two IP sides that are connected by the IC. 
Order of the $n$-faces $x$, $y$ have to match the orientation of the IP which is the same as the orientation of $S_2$ triangle, 
that is counterclockwise around the interior with normal pointing to us.
Having $x$, $y$ in right order, we set $F_c[x]=u$, $F_f[u]=y$.

\begin{figure}[!htb]
    \centering    
    \includegraphics[width=0.65\textwidth]{\figpathins tracing_color.pdf}
    \caption[Intersection 2d-3d example -- ICs ordering.]
    {An example of an intersection 2d-3d, demonstrating the ICs ordering. We see at every 
    intersection polygon corner $p_i$ which \nfaces it lies on. Looking at $p_0$, the connection table entries
    are: $F_c[s_2]=p_0$, $F_f[p_0]=s_0$. For the other ICs we have: $F_c[s_0]=p_1$, $F_f[p_1]=f_1$, $F_c[f_1]=p_2$, $F_f[p_2]=f_2$ and $F_c[f_2]=p_3$, $F_f[p_3]=s_2$.}
    \label{fig:tracing}
\end{figure}

This simple approach works well even for most of the degenerated ICs, however in order to deal with some special cases and 
with duplicity of ICs at vertices, we further mark by a~\emph{backlink} $F_c[y]=u$ the $n$-faces that success some IC but still do not possess its successors.
If $y$ already have the backlink we swap $x$ and $y$. The result is the \emph{set links} (SL) operation formalized in \algo{algo:set_links}.
\begin{algorithm}
  \caption{2d-3d intersection, set links}
  \label{algo:set_links}
  
  \DontPrintSemicolon  
  \KwIn{$n$-face $x$, IC $p$, $n$-face $y$}
  \If{$F_f[F_c[y]]=y$}{
    swap $x$ and $y$ \tcp*{$y$ success an IC already}
  }
  $F_c[x]=u$, $F_f[u]=y$\;
  \lIf{$F_c[y]$ is unset}{ $F_c[y] = u$}
\end{algorithm}





\subsubsection{Intersections on Sides of Triangle}
\algo{algo:colect_23_ip_triangle} computes all ICs on the boundary of $S_2$.  It iterates over the sides of the triangle $S_2$ 
computing  the line-tetrahedron intersection $L$ for every side $s$. 
In the regular case ($\abs{L}=2$), we process each IC in $L$ (line \ref{line:one side loop}).
The IC $p$ is appended to $I$ and successor tables are set using the SL operation. If $p$ is at the vertex of
$S_2$ the links connect the vertex with the $S_2$ side. In both cases SL  is called with the side $s$ as the target $n$-face
since SL correctly swap $n$-faces if the side is already used as the target. The vertex ICs are added twice into $I$ and are merged
in the final step.

The case $\abs{L}=1$ can happen only if the boundary of $S_2$ touches the boundary of $S_3$. These ICs will be 
rediscovered again in \algo{algo:collect_23_ip_edges} with better topological information, however this is not the 
case if the touched edge $e$ of $S_3$ is coplanar with $S_2$ and the IC is inside of $e$.
To this end we call SL with $e$ as the target which allows to use the backlink and get the already computed IC if it is rediscovered later on.
The ICs at vertices of $S_2$ are treated differently, but it follows the same idea. The ICs at vertices of $S_3$ are skipped.

\begin{algorithm}
  \caption{2d-3d intersection, ICs on sides of $S_2$}
  \label{algo:colect_23_ip_triangle}

  \DontPrintSemicolon
  \KwIn{$S_2$ and $S_3$}
  \KwOut{List $I$ with ICs on sides of $S_2$}  
  $F_c(:)=-1,\ F_f(:)=-1$\tcp*{Unset links.} 
  \For{side $s$ of $S_2$}{ 
    $L$ = \intersectionB($s, S_3$) \tcp*{\ref{algo:13d}}
    \For{$p$ in $L$}{ \nllabel{line:one side loop}
        $p$ lies on $n$-face $x\in M_2$ and $y\in M_3$\;
        \If{$\abs{L} = 1$}{
            deal with special case \tcp*{side $s$ touching $S_3$}
        }
        append $p$ to $I$\;
        \uIf{$x$ is the vertex of $S_2$}{
            \setlinks{$x$, $p$, $s$} \tcp*{\ref{algo:set_links}}
        }
        \Else{
            \setlinks{$y$, $p$, $x$} \tcp*{$x$ is $s$}
        }
    }
  }  
\end{algorithm}




\subsubsection{Intersections on Edges of Tetrahedron}
\algo{algo:collect_23_ip_edges} uses the line-triangle intersection algorithm for the edges of $S_3$.
First, the intersection $L[e]$ is evaluated for every edge $e$ (line \ref{line:12edges}).  Then we pass through once 
again while skipping the edges with none or a~degenerate IC. For every intersection corner $p=L[e]$, we first get $n$-faces 
that would appear before and after the IC in IP.

\begin{algorithm}  
  \caption{2d-3d intersection, ICs on edges of $S_3$}
  \label{algo:collect_23_ip_edges}
  
  \DontPrintSemicolon
  \KwIn{$I$ with ICs on $S_2$ boundary, partially filled $F_f$, $F_c$}
  \KwOut{all ICs in $I$, complete $F_f$, $F_c$}  
  
  \lFor{edge $e$ of $S_3$}{$L[e]$ = \intersectionA($e, S_2$)}  \nllabel{line:12edges}
  \For{edge $e$ of $S_3$ with regular $L[e]$}{
    $p=L[e]$\;
    \uIf{ $p$ is inside $e$}{ 
        \nllabel{line:edge_faces}        
        $(f_0,\ f_1)$ = \edgefaces($e$)
    }   
    \Else($p$ at the vertex $v$ of $S_3$){       
            $(f_0,\ f_1)$ = \vertexfaces($v$,$L$)   \tcp*{\ref{algo:vertex_faces}}
            \nllabel{line:mark_edges}
    }    
    append $p$ to $I$\; 
    \uIf{ $p$ is on the boundary of $S_2$ }{
         $p$ lies on edge or at vertex $x \in M_3$\;
         \uIf{$x$ have backlink}{
            \setlinks{$x$, $p$, $f_1$}      \tcp*{\ref{algo:set_links}}
         }\nllabel{line:successor}
         \Else{
            \setlinks{$f_0$, $p$, $x$}
         }  \nllabel{line:predecessor}
    }
    \Else{
         \setlinks{$f_0$, $p$, $f_1$} \nllabel{line:insideS2}
    }   
  }  
\end{algorithm}

\begin{figure}[!htb]
  \begin{center}        
    \includegraphics[width=0.25\textwidth]{\figpathins edge_faces_color.pdf}
  \end{center}
  \caption[Order of faces adjacent to the oriented edge.]
  {The order of faces adjacent to the oriented edge $e$ pointing towards us.}
  \label{fig:edge_faces}
\end{figure}

The function \emph{edge faces} (line \ref{line:edge_faces}) returns the adjacent faces $f_0$, $f_1$ to the edge $e$
on which the IC lies (see the situation in \fig{fig:edge_faces}). 
The faces are sorted using the sign of the permuted inner product in 1d-2d intersection. The order of faces matches 
the order of sides of IP if the sign is negative. If the sign is positive, the function \emph{edge faces} returns face pair $(f_1, f_0)$.
If the IC is at the vertex $v$ of $S_3$, the function \emph{vertex faces} described later (\algo{algo:vertex_faces}) is used.
It returns a~pair of $n$-faces (face or edge) adjacent to the IC $L[e]$ at the vertex $v$ of $S_3$. 
Then $p$ is appended to $I$. If the IC $p$ is inside $S_2$, the obtained pair of $n$-faces is directly used to \emph{set links} (line \ref{line:insideS2}).
However, if $p$ is on the boundary of $S_2$ ($n$-face $x$), just one of the faces is used, complemented with $x$. Presence of the backlink 
is used to determine the correct face. 


\begin{algorithm}
  \caption{2d-3d intersection, vertex faces}  
  \label{algo:vertex_faces}
  
  \DontPrintSemicolon
  \KwIn{vertex $v$ of $S_3$, $L[:]$ intersection results for edges of $S_3$}
  \KwOut{pair of \nfaces incident with $v$ that is intersected by the plane of $S_2$}
  $e_0,\ e_1,\ e_2$ edges incident with $v$ oriented out of $v$\;   
  $s[i] = L[e_i]$, for $i=0,1,2$, \;

  \uIf{ $s[:]$ contains 1 degenerate edge $e$}{\nllabel{line:one_degenerated}
    Let $f$ be the face opposite to $e$.\;
    \uIf{other two edges $e_a$, $e_b$ have different sign}{
        $z= \edgefaces(e_a)$ \tcp*{\fig{fig:edge_faces}}
        replace $g\in z$, $g\ne f$ with $e$, \Return{$z$}
    }\lElse{
        \Return{$(v, e)$}
    }
  }  

  \uElseIf{$s[:]$ contains 1 non-degenerate edge $e$}{ \nllabel{line:two_degenerated}
    \Return{pair of degenerate edges sorted according to $\edgefaces(e)$}
  }
  
  \uElseIf{ $s[:]$ contains edge $e$ with the sign opposite to the other two}{ \nllabel{line:different_sign}
    \Return{$\edgefaces(e)$}\;
  }
  
  \Else($s[:]$ have all signs same){ \nllabel{line:same_signs}
    \Return{ $(v, v)$}\;
  }  
\end{algorithm}

\begin{figure}[!htb]
    \centering    
    \includegraphics[width=0.9\textwidth]{\figpathins vertex_faces.pdf}
    \caption[Possible cases processed in the vertex faces function.]
    {Possible cases processed in the function \emph{vertex faces}.
        Only the main features referred in the text are denoted: tetrahedron vertex $v$, edge $e$, face $f$ (stripes).}
    \label{fig:vertex_faces}
\end{figure}

The function \emph{vertex faces} in \algo{algo:vertex_faces} gets as a~parameter IC $p$ at the vertex $v$ of $S_3$ 
which is a~special case of a~non-degenerate edge-triangle intersection. There are three
edges incident with the vertex $v$, results $s[i]$ of their intersections with $S_2$ may be one of: no IC, 
a~degenerate IC, an IC with a~positive or negative permuted inner product sign.
Accordingly we say the edge is: without intersection, degenerate, positive, or negative. 
We use these edge indicators to return generalized faces of $S_3$ preceding and succeeding $p$ on the polygons boundary assuming $p$ is at the interior of $S_2$.
Possible cases are (see also \fig{fig:vertex_faces} a-e):
\begin{itemize}
 \item {\bf Single degenerate IC} (line \ref{line:one_degenerated}){\bf .} Let us denote $e$ the edge with a~degenerate IC 
 and $f$ the face between the other two edges.
 The other two (non-degenerate) edges may have either the opposite sign (the plane is cutting $S_3$, see \fig{fig:vertex_faces}, (a)) 
 or the same sign (the plane is touching $S_3$ at the edge $e$, see \fig{fig:vertex_faces}, (b)).
 In the first case, the call \emph{edge faces}$(e)$ returns $(f_x,f)$ or $(f,f_x)$, then the \emph{vertex faces} returns $(e, f)$ or $(f, e)$, respectively.
 In the second case,  there must be another IC on $e$, either at $S_2$ boundary or at the other end of $e$.
 In both cases the edge $e$ is the common $n$-face of the two intersection points thus we return 
 $(v,e)$ taking the edge as the target object.

 
 \item {\bf Two degenerate ICs} (line \ref{line:two_degenerated}){\bf .} A~face of $S_3$ lies in the plane of $S_2$,
 see \fig{fig:vertex_faces}, (c). 
 Let $e$ be the single non-degenerate edge. We treat the two degenerate edges as faces adjacent to $e$ 
 and return them sorted like the faces given by \emph{edge faces} of the edge $e$.
 
 
 \item {\bf Single IC has the opposite sign to the other two} (line \ref{line:different_sign}){\bf .} 
 Let $e$ be the edge of the single IC with the different sign. 
 The plane of $S_2$ separates $e$ from the other two edges so it goes through the faces adjacent to $e$,
 see \fig{fig:vertex_faces}, (d).
 The order is determined by the function \emph{edge faces} called for the edge $e$.

 \item {\bf All ICs have the same sign} (line \ref{line:same_signs}){\bf .} Since $S_2$ is touching $S_3$ 
 at the vertex $v$, \fig{fig:vertex_faces}, (e), the polygon degenerates into a~point and thus no connection information is necessary.
 We just return $(v,v)$.
\end{itemize}

\subsubsection{Ordering of Intersections}
The final stage of the 2d-3d intersection is the ordering of ICs. We start with the first IC in $I$ and follow the 
successor tables until we return back to the first IC. The ICs are copied into a~resulting vector, skipping all the duplicities.
Special action must be taken in degenerate cases with less than $3$ ICs, since they cannot form a~cycle.


\subsection{Intersection Triangle-Triangle (2d-2d)}
Let us now consider two triangles $S^a_2$ and $S^b_2$, whose intersection consists of at most 2 ICs,
i.e we do not assume the triangles to overlap when lying in the same plane (we do not need this in our applications).
Each IC can arise from a~side-triangle intersection, while we determine this intersection for each of 6 possible combinations.
We have to compute 6 \plucker coordinates for the sides of both triangles and 9 permuted inner products, one per every side-side pair.
In case of two ICs no sorting is performed, there is no need for that.

\begin{algorithm}
  \caption{2d-2d intersection}
  \label{algo:22d}

  \DontPrintSemicolon
  \KwIn{Triangles $S^a_2$ and $S^b_2$.}
  \KwOut{List $I$ of ICs.}  
  $I=\{\}$\; 
  \For{unmarked side $s^a$ of $S^a_2$}{
    $L$ = \intersectionA{$s^a,S^b_2$}\;
    \For{$p$ in $L$}{                   \nllabel{line:sideA}
        \If{$p$ is vertex $v^a$ of $S^a$}{
            set $\tau_{S^a_2} = (0,v^a)$\; \nllabel{line:set_tau_va}
            mark sides of $S^a_2$ incident to $v^a$
        }
        \lIf{$p$ is vertex $v^b$ of $S^b$}{ mark sides of $S^b_2$ incident to $v^b$ }
%             set $\tau_{S^b_2} = (0,v^b)$\;
        \lIf{$p$ lies on a~side $s^b$ of $S^b$}{ mark side $s^b$ of $S^b_2$ }
%             set $\tau_{S^b_2} = (1,s^b)$\;
    }
    append $L$ to $I$\; 
    \lIf{$\abs{I}=2$}{\Return{I}} \nllabel{line:2d2d_return1}
  }
  \For{unmarked side $s^b$ of $S^b_2$}{ \nllabel{line:sideB}
    $L$ = \intersectionA{$s^b,S^a_2$}\;
    \For{$p$ in $L$}{
        \If{$p$ is vertex $v^b$ of $S^b$}{
            set $\tau_{S^b_2} = (0,v^b)$\;
            mark sides of $S^b_2$ incident to $v^b$
        }
    }
    append $L$ to $I$\;
    \lIf{$\abs{I}=2$}{\Return{I}} \nllabel{line:2d2d_return2}
  }
\end{algorithm}

The computation of the triangle-triangle intersection is sketched in \algo{algo:22d}.
We use the 1d-2d algorithm from Section \ref{sec:1d-2d} as we did before, but including the degenerate case and
full topology information (in contrast to the 1d-3d case).
We solve all the possible side-triangle pairs in cycles at lines \ref{line:sideA}, \ref{line:sideB},
however we mark potential sides to be skipped in some special cases.
We also end the computations when two ICs are computed already, lines \ref{line:2d2d_return1}, \ref{line:2d2d_return2}.

Looking at the first cycle over the sides of the first triangle, the special case from the line segment $s^a$ perspective is
an IC at one of its end points. Then the topology position must be updated to the triangle vertex, line \ref{line:set_tau_va}.
Also the other side connected to the vertex is marked so it can be skipped later.
The topological position of the IC from the triangle $S^b_2$ perspective is already known from 1d-2d algorithm.
Additionally, we can mark the sides of $S^b_2$, if the IC is at its vertex, or mark the side $s^b$, if the IC lies on it.

If the algorithm reaches into the second cycle over the sides of the triangle $S^b_2$,
we do not have to check the special cases on the triangle $S^a_2$, because these would have been found already.
The only thing to check is whether the IC is at the end point of $s_b$ and update its topological position in $S^b_2$.

\section{Global Mesh Intersection Algorithm}
\label{sec:front_advancing}
Having the algorithms for all the element-element intersections at our disposal we can proceed to the mesh intersection algorithm. 
We consider a~composed mesh $\mathcal T$ containing a~3d mesh $\mathcal T^1$ that we call a~bulk mesh $\mathcal T_b$. Any other 
mesh $\mathcal T^i$, of lower dimension, $i=2\dots N_{\mathcal T}$, we call a~component mesh. 
We first compute all component-bulk mesh intersections, i.e. 1d-3d and 2d-3d, using the advancing front algorithm which is described in Sections 
\ref{sec:initiation}, \ref{sec:front}.
Then the 1d-2d and 2d-2d intersections are computed using the bulk mesh results to get the intersection pair candidates.
This step is described in Section \ref{sec:components}.

Let us now consider a~single pair of the component mesh $\mathcal T_c$ and the bulk mesh~$\mathcal T_b$. 
Element intersections for this pair of meshes are obtained in two phases: first, the 
first pair $(c,b)$ of the component and the bulk elements with a~non-empty intersection is searched (the initiation);
second, the intersection is prolonged by investigating neighboring elements (the front tracking).


% \textbf{breadth first search} algorithm:
%   \begin{enumerate}
%     \item\label{en:first} Get next unprocessed component element $k$.
%     \item Find intersection candidates $\mathcal K$ in bulk mesh (3d elements).W
%     \item \label{en:q2}For $K\in \mathcal K$ compute intersection $(k, K)$.  
%     \item Push the intersection neigbours into queues: $(k, L) \to Q_b$, $(l, K) \to Q_c$. 
%     \item While $(l, L) \in Q_b$ check intersection $(l, L)$. Append queues.
%     \item Pop pair from $Q_c$. (move to the next component element: go to \ref{en:q2}).
%     \item If $Q_c$ is empty, go to \ref{en:first}.
%   \end{enumerate}

\subsection{Initiation}
\label{sec:initiation}
Given a~component element $c$, the intersecting bulk element $b$ has to be found.
If this step is performed only a~few times, the optimal way is to iterate over the bulk mesh and to test its every element.
This process may be accelerated by computing the AABB for every element, then the intersection of the bounding boxes can be used
as a~fast indicator for possible element intersection. This step takes time $O(N)$ with respect to the number of elements of the bulk mesh $N$.
If the number of components $k$ is small and if the components are contained inside the bulk mesh, the total time of the initiation 
may still be linear $O(kN)$. However, for more complex cases we organize the bounding boxes of the bulk mesh into the bounding interval
hierarchy (BIH)~\cite{wachter_instant_2006}, a~data structure in principle equivalent 
to the R-trees \cite{guttman_r_trees_1984}, \cite{nam_comparative_2004}. The construction of a~BIH takes time $O(N\log(N/n))$ 
and the search time is $O(\log(N/n))$ where $n$ is the number of the bulk elements in the leaf nodes of the tree.
 
\subsection{Advancing Front Method}
\label{sec:front}
The advancing front algorithm requires the neighboring information for the elements within the component mesh $\mathcal T_c$ 
as well as within the bulk mesh $\mathcal T_b$. It can be viewed as a~breadth first search algorithm for a~graph where the graph vertices are 
the intersection polygons and the graph edges are the IP sides shared by two IPs. Since every side of an IP is on the boundary of either 
a~component element or a~bulk element, we can distinguish bulk and component edges. 
Correspondingly we use a~\emph{component queue} $Q_c$ and a~\emph{bulk queue} $Q_b$ in which we place intersection candidate pairs $(c,b)$.
In order to process every pair $(c,b)$ only once, we check whether the pair was already processed, before it is enqueued into one of the queues.
Only if the pair was not yet processed, we mark it processed and push it into the queue.
Since the number of possible pairs is too big, we cannot have a~flag array
which would allow constant time checks. Therefore, we keep a~hash table of the processed pairs which allows the constant check on average.

The key idea behind the two queues is to compute intersections for a~component element with all possible bulk elements at first,
and then move to a~next neighboring component element. So the bulk queue is emptied before the component queue.
% \begin{algorithm}
%   \caption{Advancing front algorithm}  
%   \label{algo:advancing front}
%   
%   \SetKw{return}{return}
%   \SetKw{edgefaces}{edge faces}
%   \DontPrintSemicolon
%   %\KwIn{vertex $v$ of $S_3$, $L[:]$ intersection results for edges of $S_3$}
%   %\KwOut{$(x_1, x_2)$, $x_1, x_2 \in M_3$, incident with $v$ and intersected by the plane of $S_2$}
%   mark all $c\in \mathcal T_c$ unvisited\;
%   $\gamma=0$ \tcp*{component number}
%   \For{unvisited $c\in\mathcal T_c$}{
%     increment $\gamma$\;
%     find list $L$ of intersection candidates\;
%     append $L$ to queue $Q_c$\;
%     \For{$(c, b) \in Q_c$}{
%         mark $c$ visited\;
%         push $(c,b)$ into $Q_b$\;
%         \For{$(c, b) \in Q_b$}{            
%             list $I$ of ICs of $(c,b)$ intersection\;
%             set $\gamma$ into IP\;
%             \For{$p\in I$}{
%                 \If{$p$ on boundary of $c$}{
%                     get neighbors $C'$\;
%                     \tcp{check pair if unvisited, mark visited}
%                     enqueue $(c', b)$ into $Q_c$ for all $c'\in C'$ 
%                 }
%                 \If{$p$ on boundary of $b$}{
%                     get neighbors $B'$\;
%                     \If{$B'$ is empty and not on boundary of $c$}{mark $c$ unvisited}
%                     enqueue $(c, b')$ into $Q_b$ for all $b'\in B'$ 
%                 }                
% %                 \noteJB{Questionable}\;
% %                 \If{$p$ on both boundaries}{
% %                     enqueue $(c', b')$ into $Q_c$ for all $b'\in B',\ c'\in C'$ 
% %                 }
%             }        
%             
%         }
%     }
%   }
%   
% \end{algorithm}

First, we mark all the component elements $c\in\mathcal T_c$ as unvisited. 
For every unvisited element $c\in \mathcal T_c$, 
we find some intersection candidate pairs $\{(c,b): b\in\mathcal T_b\}$ and
push them into the queue $Q_c$.
Then we increment the \emph{component number} $\gamma$, which we use to 
mark all intersection polygons we find until the queue $Q_c$ is empty.
This way, we later know to which component a~given IP belongs to, 
which will become important in Section \ref{sec:components}.
This is from where the front tracking starts, see the top-left corner of the scheme in 
\fig{fig:prolongation}.
%
\begin{figure}[!htb]
%   \vspace{0pt}
  \centering    
    \includegraphics[width=\textwidth]{\figpathins prolongation_scheme_ip_pe_final.pdf}
  \caption{Advancing front algorithm for 1d-2d and 2d-3d intersections.}
  \label{fig:prolongation}
\end{figure}

We dequeue the first candidate pair $(c,b)$ from $Q_c$ and compute the IP.
If the intersection exists, we look for the new candidate pairs among the neighboring elements
(see the big white block in \fig{fig:prolongation}).
Therefore, we iterate over ICs of the IP and further exploit their topological position on the component element $c$ and the bulk element $b$.
For every IC, one or both of the following cases may happen:
\begin{enumerate}[label=(\alph*)]
    \item \textbf{IC is on the boundary of $c$.}
    
            We find all the sides $S$ of $c$ incident with the \nface of $c$ on which IC lies. Then we get all component
            elements $C'$ neighboring with $c$ over any side $s\in S$. And finally, we push all pairs $(c',b)$, $c'\in C'$ 
            into the component queue. Note that $c$ can have more than one neighbor component elements on a~single side $s$, i.e. branches are allowed.
    \item \textbf{IC is on the boundary of $b$.} \label{enum:prolong2}
    
            We find all the faces $F$ of $b$ incident with the \nface of $b$ on which IC lies. 
            Then we get all bulk elements $B'$ neighboring with $b$ over any face $f\in F$,
            analogically to the previous case.
            Finally, we push the new candidate pairs $(c, b')$, $b'\in B'$ into the bulk queue.
            However, if the list $B'$ is empty, which means that the component element $c$ extends out of the bulk mesh,
            we mark the element $c$ as unvisited again. This way we have a~chance to find possible other intersection of the element
            $c$ with the bulk mesh in the main loop. Note that every time this happens, the possible further intersection 
            of the current $c$ will be seen as different component with increased component number $\gamma$
            (see an example situation in \fig{fig:components}). 
\end{enumerate}

\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.55\textwidth]{\figpathins components.pdf}
    \caption[Components in non-convex bulk domain.]
    {For a~non-convex bulk domain a~situation as this may happen. The 1d elements 3, 4, 5 extend out of the bulk mesh.
    Therefore, four initiations are needed to find all four 1d-3d intersections, each one of them forming an independent component. 
    Advancing front method cannot play any part in this situation.}
    \label{fig:components}
\end{figure}

We see that $(c, b')$ can prolong the intersection over a~bulk element face, on the other hand $(c', b)$ 
may prolong the intersection over the component side. If the IC lies both on the boundaries of $c$ and $b$,
we obtain candidate pairs of both types. Having all ICs processed, we continue emptying the queues. We empty the bulk queue first,
trying to fully cover the current component element $c$ before we proceed to the next one. 

\subsection{Intersections Between Component Meshes}
\label{sec:components}
We consider here a~situation where the component meshes are in the interior of the 3d bulk mesh. After we compute
all component-bulk intersections, we use it to easily find all the component-component intersection candidate
pairs.
If the bulk element intersects more than one component element, then we look for candidate pairs only among these.

Let us start with the description of how we store the intersection results, which will be of great importance here.
For each element intersection, we save the following data: references to the component and bulk element, 
the barycentric coordinates on both and the component number $\gamma$. These objects are stored in separate vectors for each pair of dimensions.
Further we define a~matrix (\emph{intersection map}) which has as many rows as there are elements in the mesh.
At each row, we save the references to all other elements, having intersection with the element corresponding to this row, and references to the actual intersection data.

The algorithm for 2d-2d intersections works as follows. We iterate over all 2d-3d intersections, i.e. over
the bulk elements having some intersections with 2d components. We look at the intersection map at the
bulk element $b$ row and collect all the 2d elements that have intersection with $b$.
Then we create all possible pairs from the collected component elements.
Now the component number $\gamma$ comes into play. If the elements of a~single pair have $\gamma$ equal, then 
these are neighboring elements of a~single continuous component and we do not compute any intersection.
Otherwise we obtain a~new candidate pair, for which IP can be computed.

The algorithm for 1d-2d is analogical, only we do not have to check the component number.
Note that this way, we do not obtain any intersection in the exterior of the bulk mesh.
If such problem is of our interest, we find the candidate pairs using the search algorithms as in
the initiation phase of the advancing front method.


% After computing the intersection of a~pair of elements (line or triangle vs tetrahedron), we fill
% two queues with element pairs as candidates for further intersection. If the intersection edge 
% (point of line in 1d, edge of polygon in 2d) is inside the tetrahedron, not on its surface, we
% get a~neighboring element of the component and push it back together with the current tetrahedron into 
% \emph{component prolongation queue}. If the intersection edge is inside the \emph{slave} element 
% (line or triangle), i.e. is on the surface of tetrahedron, we get a~neighboring element of the tetrahedron
% and push it back together with the current slave element into \emph{3d prolongation queue}.


%Then we empty the two queues. 
%We pop out new candidate pairs from the \emph{bulk queue} as long as it is not empty and for every new intersection computed, 
%we repeat the previous part (means that we can further fill both queues).
%The \emph{bulk queue} is empty when the component element is fully covered by bulk elements, or
%when there is no bulk neighbor to which we can advance.
%Then we can pop a~new candidate pair from \emph{component prolongation queue} and process it.
%When both queues are empty, all intersections of a~component have been found and we start over by looking for the first intersection of another component.

%\notePE{We can discuss further the covering/closing of the elements and component numbering which is not tested
%thoroughly at the moment. We can show in a~figure the case in 'prolong\_meshes\_13d/prolongation\_13d\_04.msh', where actually 4 components are found (therefore bulk is defined as connected 3d elements).}

% The algorithm is now unified for 1d and 2d in contrast to \cite{fris_dp_2015}, where the component prolongation
% queue is emptied at first.

% \subsubsection{1d-3d prolongation}
% 1d-3d prolongation logic
% IC is:
% - 1d element node
%     - inside tetrahedron
%         - get the neighboring 1d element
%         - push to component queue candidate pair [1d neigbor -- tetrahedron]
%     - on the surface of tetrahedron
%         - get all faces in which the IC lies (1 face, or 2 faces (edge), or 3 faces (node))
%         - get the tetrahedron neighbors on the faces
%         - push to bulk queue new candidates pairs:
%             - [current 1d element -- tetrahedron neighbor]
%             - [1d neighbor -- tetragedron neighbor]
%             - check whether the candidate pair has not been computed yet
%             (- if no new prolongation, push empty pair; means IC is on the boundary; 
%                the element is not closed then -- not fully covered with tetrahedrons)
% - inside 1d element
%     - get all faces in which the IC lies (1 face, or 2 faces (edge), or 3 faces (node))
%     - get the tetrahedron neighbors on the faces
%     - push to bulk queue candidate pair [current 1d element -- tetrahedron neighbor]
%     - check whether the candidate pair has not been computed yet
%     (- if no new prolongation, push empty pair; same meaning as above)

% A~new candidate pair of elements is found during prologantion, based on the topological information of the intersection corner. There are 3 possible cases:

% \begin{itemize}
%     \item \textbf{IC lies at 1d element node and inside 3d element} \\
%             We find the neighboring 1d element over the node and push a~new candidate pair [1d neighbor -- current 3d element] into component queue.
%     \item \textbf{IC lies at 1d element node and on the surface of 3d element} \\
%             We find all the faces of 3d element in which the IC lies (1 face, or 2 faces (IC on an edge), 
%             or 3 faces (IC at a~node)). We find the corresponding neghboring 3d elements over the faces and
%             push the following new candidates pairs into the bulk queue: [current 1d element -- 3d neighbor], [1d neighbor -- 3d neighbor].
%             If the candidates pair has been investigated already, we skip it.
%     \item \textbf{IC lies inside 1d element (therefore must be on the surface of 3d element)} \\
%             The same as before, but we push only [current 1d element -- 3d neighbor] candidates pairs, since
%             there is no 1d neighbor.
% \end{itemize}



% 2d-3d prolongation logic CURRENT
% IC is:
% - inside 2d element side
%     - inside 3d element
%         - get the neighboring 2d elements over the side
%         - push to component queue candidates pair [2d neigbor -- current 3d element]
% - inside the face of 3d element
%     - get the neighboring 3d element over the face
%     - push to bulk queue candidate pair [2d neighbor -- 3d element]
% 
% 2d-3d prolongation logic WITH FUTURE CORRECTIONS
% IC is:
% - on 2d element side
%     - find 2d element sides (if at node) and the corresponding neighbors
%     - inside 3d element
%         - push to component queue candidates pairs [2d neigbor -- current 3d element]
%     - on the surface of 3d element
%         - get all faces in which the IC lies (1 face, or 2 faces (edge), or 3 faces (node))
%         - get the 3d neighbors over the faces
%         - push to bulk queue new candidates pairs
%             - [current 2d element -- 3d neighbor]
%             - [2d neighbor -- 3d neighbor] (all combinations)
%             - check whether the candidate pair has not been computed yet
% - inside the 2d element (=> on the surface of 3d element)
%     - get all faces in which the IC lies (1 face, or 2 faces (edge), or 3 faces (node))
%     - get the 3d neighbors over the faces
%     - push to bulk queue new candidates pairs [current 2d element -- 3d neighbor]
%     - check whether the candidate pair has not been computed yet





\section{Benchmarks}
\label{sec:benchmarks}

In this section, we present numerical results on several benchmark problems. 
The theoretical number of floating point operations (FLOPs) is analyzed in our element intersection algorithms with 
other state of the art algorithms.
Next, a~comparison of our algorithms is provided, including different initiation phases (candidate pairs search),
and using the advancing front method or not. We show the results both on a~mesh of a~real locality
and an artificial mesh.

The implementation of the algorithms is a~part of the software Flow123d.
We note, that internally in Flow123d, the open source C++ library Armadillo~\cite{armadillo_2016} is used
for fast vector and matrix operations.
This library is specialized for linear algebra in C++, with a~high-level syntax deliberately similar to Matlab.


\subsection{Theoretical Comparison}
It proved to be a~bit problematic to compare the presented algorithms for element-element intersections to any of the state of the art
algorithms e.g. from the field of computer graphics. The algorithms for computer graphics applications are specialized for
the 1d-2d and 1d-3d cases and they provide different output information than our algorithms. Moreover, our implementation 
is not yet fully optimized to be on par with the fine tuned implementations. Instead, we present a~theoretical comparison 
in terms of the estimated number of FLOPs performed by individual algorithms. Since the intersection 
algorithms work on small data, they should not be limited by the memory access; thus, such comparison may be realistic. 

We consider 3 algorithms for the line-triangle intersections: \plucker algorithm 
described in Section \ref{sec:1d-2d}, the algorithm based on the plane clipping due to Haines \cite{haines_fast_1991}, and the minimum storage
algorithm due to M{\" o}ller and Trumbore (MT) \cite{moller_fast_1997}. For the later two algorithms we consider straightforward modifications
to make them return a~qualitatively same output as our algorithms do in 1d-2d, 1d-3d, and 2d-3d cases.
The estimated numbers of FLOPs for all cases are summarized in Table \ref{tab:fundamental_flops}.
For the \plucker algorithm, we count FLOPs actually made by the implementation of individual intersection algorithms. For Haines and MT, 
we estimate the number of FLOPs in theoretical implementations. In particular, we consider reusing of the calculations in \plucker and Haines algorithms. 
Conclusions from this census are: algorithms based on the \plucker coordinates should be competitive with the state of the art algorithms in case of 1d-3d 
and 2d-3d intersections. The expected performance for the 1d-2d case seems to be poor, however these intersections are computed after 1d-3d and 2d-3d,
so the \plucker coordinates may be reused. Considering this scenario we get quite competitive 45 FLOPs. 
Similarly, we may expect better results in the remaining two intersection cases when the \plucker coordinates and their products 
are reused by neighboring elements.


\begin{table}[!htb]
\begin{center}
\bgroup
\def\arraystretch{1.2}
\setlength\tabcolsep{5pt}
\begin{tabular}{l|lll}
\toprule
    algorithm            & 1d-2d   & 1d-3d    & 2d-3d \\ \midrule
    \plucker             & 92      & 198      & 426 \\
    \plucker (edge reuse)& 45      & 138      & 264 \\
    Haines               & 51      & 177      & 469 \\
    M\"oller and Trumbore  & 42      & 168      & 756 \\
\bottomrule
\end{tabular}
\caption[Comparison of intersection algorithms by FLOPs.]
    {Raw number of FLOPs used by different intersection algorithms. Second row contains the estimated effective number of FLOPs per intersection,
    accounting for reusing the computed \plucker data over neighboring elements, while assuming data on edges of 2d and 3d elements are used twice (conservative).}
\label{tab:fundamental_flops}
\egroup
\end{center}
\end{table}


% \subsection{Element Intersection Algorithms}
% The first benchmark focuses on the 1d-3d and 2d-3d element intersections. We randomly generated
% 100000 element pairs inside a~unit cube, from which approximately 65\% have nonempty intersection.
% Only the pairs with non-colliding bounding boxes were included to the timing.  
% Every element pair was computed 100 times to obtain reasonable computational time.
% \noteJB{According to the results the time of single pair is on average 2e-5s. Normal system times have resolution about 20ms, hi-resolution timers
% used in profiler have resolution about 1ms. So we need at least 10000 calls per single pair to get meaningful results.}
% 
% \noteJB{Mention the hardware configuration to get an context for the timing.}
% 
% \begin{figure}[!htb]
%     \centering
%     \includegraphics[width=0.5\textwidth]{\figpathins intersections_fundamental_speed.pdf}
%     \caption{Efficiency of \plucker approach compared to the legacy \ngh code.}
%     \label{fig:fundamental_speed}
% \end{figure}
% 
% We see the benchmark results in the \fig{fig:fundamental_speed}. Green values correspond to the presented algorithms
% using \plucker coordinates, red values to \ngh code. The gained speed up factor is approximately 5 in 1d-3d case and 2 in 2d-3d. 
% \noteJB{Just the opposite what we expect. Just by chance?}

\subsection{Global Mesh Intersections}
The global mesh intersection algorithm for a~composed mesh $\mathcal T$ presented in Section \ref{sec:front_advancing} is
implemented in three variants, see Table \ref{tab:search_algorithms}.
\begin{table}[!htb]
\begin{center}
\bgroup
\def\arraystretch{1.2}
\setlength\tabcolsep{5pt}
\begin{tabular}{r
                >{\centering\arraybackslash}p{20ex}
                >{\centering\arraybackslash}p{20ex}
                >{\centering\arraybackslash}p{20ex}}
    \toprule
    &   \colorbox{red}{\textcolor{white}{FS+AF\vphantom{By}}} &
        \colorbox{NavyBlue}{\textcolor{white}{BIH+AF\vphantom{By}}} & 
        \colorbox{Goldenrod}{BIH\vphantom{By}} \\ \midrule
    init. & AABB & BIH(AABB) & BIH(AABB) \\
    AF   & $\bullet$ & $\bullet$ & --- \\
    \bottomrule
\end{tabular}
\caption{Three variants of the global mesh algorithm.}
\label{tab:search_algorithms}
\egroup
\end{center}
\end{table}
The first variant FS+AF uses a~full search (FS) over the bulk mesh, i.e. it uses only the unordered array of AABB of elements,
to get the initial pair for the advancing front algorithm (AF).
The second variant uses the BIH on top of AABB to accelerate the initiation of the AF algorithm.
The third variant does not use AF at all and relies on the search through BIH only. 

We now compare these three variants on an artificial composed mesh and on a~mesh raising from a~real hydrogeological simulation.
The 2d-3d intersections are considered only, the other types are not computed in the tests.
Regarding the time results, the algorithms were run on a~personal laptop with Intel Core i7-3630QM, $8\times 2.4$ GHz CPU, 8 GB RAM,
Ubuntu 16.04 LTS 64-bit system, with Flow123d compiled with O3 optimization.

Let us start with the artificial case. The composed mesh consists of a~cube and two diagonal rectangular 2d meshes (see \fig{fig:cube_mesh}).
A sequence of meshes is prepared with an increasing number of elements ranging
from $33$ up to $2000$ thousands. The mesh step of the bulk mesh is about half the mesh step of the component mesh in each realization. 
The number of the bulk-component intersections varies from $0.1$ up to $2.0$ millions.
%
\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.47\textwidth]{\figpathins test1_cube0.pdf}
    \caption[Artificial mesh -- cube.]
    {The artificial mesh: a~cube with two perpendicular planes placed along its diagonals.
        The planes are also incompatible, therefore they can be seen as two independent components.}
    \label{fig:cube_mesh}
\end{figure}

The time consumption of the three compared variants
of the mesh intersection algorithm is shown in \gref{graph:cube_speed}.
Every algorithm consists of the initiation phase which processes all the elements of the mesh 
and the intersection phase which depends only on the number of elements in the component mesh.
Under these terms both phases of all three variants exhibit almost 
linear time complexity. Due to the low number of the component meshes which are completely covered by the bulk mesh,
the FS+AF variant is the fastest one, in particular in its initiation phase.
On the other hand the BIH variant is about two times slower than the BIH+AF variant during the intersection phase. 
That is roughly related to the average fraction of the non-intersecting 3d element in the bounding box of a~2d element.
  
\begin{graph}[!htb]
    \centering
    \includegraphics[width=\textwidth]{\figpathins cube_scale.pdf}
    \caption[Time complexity of intersection algorithms.]
    {The time complexity for the initiation phase (left) with respect to the total mesh size
        and the intersection algorithm (right) with respect to the size of the component mesh.}
    \label{graph:cube_speed}
\end{graph}



Next, we study the performance of the intersection algorithms on a~mesh of a~real problem, see \fig{fig:bedrichov_meshes}.
The mesh represents a~mountain ridge above a~water supply tunnel in Bed{\v r}ichov in the Jizera mountains.
The mesh includes a~system of geological fractures (\fig{fig:bedrichov_cut}).
In order to study the influence of the component elements outside of
the bulk mesh, we also prepare a~mesh with artificially extended fractures (\fig{fig:bedrichov_extend}). 
Each of these meshes contains 28 fractures, however some of them are compatibly connected so there are 9 separated 2d components
and a~single 1d component (the supply tunnel).
%
\begin{figure}[!htb]
    \subfloat[interior fractures]{
        \includegraphics[width=0.482\textwidth]{\figpathins bedrichov_fract.pdf}
        \label{fig:bedrichov_cut}
    }
    \subfloat[extending fractures]{
        \includegraphics[width=0.482\textwidth]{\figpathins bedrichov_fract_extend.pdf}
        \label{fig:bedrichov_extend}
    }
    \caption[Mesh of the real locality of Bed{\v r}ichov in the Jizera mountains.]
    {A mesh of the real locality of Bed{\v r}ichov in the Jizera mountains.
             We see the fractures inside the bulk mesh on the left,
             the fractures are extending from the bulk mesh on the right.}
    \label{fig:bedrichov_meshes}
\end{figure}

The results for both meshes can be seen in \gref{graph:bedrichov_speed}, pay attention to the different time
scales on each side of the graph. In the first case, we notice that FS+AF and BIH+AF algorithms are nearly twice as fast as BIH.
The fraction of the non-intersecting 3d elements in the bounding boxes of the 2d elements is higher as the 3d elements are smaller than the 2d elements
on average.
Creating the BIH in the BIH+AF variant pays off and the algorithm performs better than the FS+AF variant.
This is in contrast to the cube test case since the number of the component meshes is higher.

In the second case, we observe a~large blow up for the FS+AF variant. It is caused by the exterior component elements
for which all the bulk elements bounding boxes are iterated before the algorithm concludes that there is no intersection.
The better performance of both BIH and BIH+AF variants is evident in this case.


\begin{graph}[!htb]
    \centering
    \includegraphics[width=0.8\textwidth]{\figpathins intersections_bedrichov_both_speed.pdf}
    \caption[Comparison of the algorithms on meshes of Bed{\v r}ichov locality.]
    {Comparison of the algorithms on meshes of Bed{\v r}ichov locality -- 
        interior fractures on the left,
        extending fractures on the right.}
    \label{graph:bedrichov_speed}
\end{graph}



\section{Summary}
Algorithms for computing intersections of pairs of simplicial elements were suggested in this chapter.
The algorithms are based on computation of the \plucker coordinates of the elements edges
which may be reused between the elements of a~mesh. The algorithms were theoretical compared
by their complexity in terms of FLOPs count estimates with other state of the art algorithms.
From this point of view, the suggested algorithms seem to be very competitive with the others,
especially when the \plucker coordinates and the permuted inner products can be reused.

Three variants of the global mesh intersection algorithm for a~composed mesh were proposed.
In two of them a~specialized advancing front algorithm was used.
All three algorithms were tested and compared on benchmark problems, indicating
which ones are the most suitable in different cases.
Looking back at the results, the variant BIH+AF is recommended in general,
while the FS+AF might be more efficient when there are few component meshes inside a~bulk mesh.

The algorithm is a~part of the software Flow123d and the results were published in the article~\cite{brezina_2017}.
It is currently used in the experimental Mortar model for flow
and in the XFEM models presented in Chapter~\ref{chap:xfem_mh}. The obtained intersections indicate
the positions of the singularities and the AABB of the elements are also used when the enrichment zone is determined.




% \section{Acknowledgement}
% The paper was supported in part by the Project OP VaVpI Centre for Nanomaterials, Advanced Technologies  and Innovations
% CZ.1.05/2.1.00/01.0005.
% 
% The work of P. Exner was supported by the Ministry of Education of the Czech Republic within the SGS project no. 21176/115 of the Technical University of Liberec.


% \cite{sukumar_extended_2000} - Use {\emph geometric predicates} incircle and orientation. Use mesh of bounding boxes to search for intersection candidates. 
% Only use point queries for all vertices of triangle/tetrahedron. Use compatible partitioning of elements by the crack elements.
% 
% \cite{boon_robust_2016} Robust discretization of porous media. Complete error analysis with mortar non-compatible case. Seems they use normal fluxes accros
% fracture instead of pressure traces. This allows conforming discretization and error results.
% 
% \cite{reichenberger_mixed-dimensional_2006} Finite volume method, fully implicit two phase flow. Cite usage of FRAC3D generator. 
% 
% \cite{sladkova_bakalarka} Space-time DG with adaptive mesh, need integration of product of functions on different meshes (in 2d). An algorithm 
% for computing triangle-triangle intersections in 2d.
% 
% \cite{pichot_generalized_2012} DFN + MHFEM. Mortar method for intersections. Focused on formulation not on intersections. 
% 
% \cite{flemisch_non-matching_2012} (Barbara) Mortad, non=matching, acustics. Theory, structured gird case. No complex intersections.
% 
% \cite{mustapha_hybrid_2014} Patent for curiosity.
% 
% \cite{mittal_immersed_2005} Immersed boundary. ??
% 
% \cite{owen_survey_1998} ??
% 
% \cite{kuznetsov_overlapping_1998}
% 
% Review of algorithms: \cite{gander_algorithm_2009}
% 
% USED:
% \cite{platis_fast_2003} Original algorithm for line-thetrahedra intersections.
% 
% \cite{haines_fast_1991} Line-convex Polyhedra intersections using generalisation of line-clipping algorithm
%
% \cite{massing_efficient_2013} - Implementation of the Nitche method in Fenics. They need 2d-3d intersections, but only for distribution od quadrature points. 
% So they do not store whole intersection data, but only the quad points. The boundary of one domain is partitioned into intersections with elements of the other domain.
% Use {\\emph collision relations} ( pairs of faces of boundary and elmements of the background mesh) and {\emph collision maps} 
% ( map face to all intersections and background element to all intersections, can be constructed from the collision relation), They cite books from computer graphics ..
% Mention geometric predicates. Present algorithms for:  find intersection candidates, comput intersections, integrate over complex domains.
% 
% \cite{elsheikh_reliable_2012} Claim to provide robust algorithm covering all tiangle-trinagle degenerate cases. Basic idea is the same as our: use some tree 
% (Binary SPace Tree) structure to find initial point on intersection curve and trace the curve in both directions. Quite clever data structure for the mesh. Adaptive precision 
% geometric predicates. Store topological information about the intersection corners (point on triangle, edge, vertex). Resolve various degenerate cases, 
% dicuss mesh optimization after subdivision.
% 
% \cite{gander_algorithm_2013} Full algorithm for 2d=3d called PANG. Implemented in DUNE in 2010 (Bastian). Other software (Hecht, MpCCI). 
% Triangle-Triangle and Tetra-Triangle intersections done similarly as in aur approach: set of points including vertices and then sort them countercolckwise.
% Local intersection algorithm do not provide neighboring information so the traversal algorithm do not use it.
% 
% \cite{bournival_mesh-geometry_2008} Application of mixed-dimensional approach in mechanics. Beam and shell elements ...
